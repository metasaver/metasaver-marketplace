#!/bin/bash
# DRY Check Scan Script Template
# Automates scanning for duplicate code against shared libraries

set -e

# Configuration
REPO_ROOT="$(git rev-root)"
SHARED_PACKAGES=(
  "@metasaver/utils"
  "@metasaver/contracts"
  "@metasaver/ui-components"
)

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Find shared package locations
find_package() {
  local package_name=$1
  # Try workspace packages first
  local workspace_path="${REPO_ROOT}/packages/${package_name##*\/}"
  if [ -d "$workspace_path" ]; then
    echo "$workspace_path"
    return
  fi

  # Fallback to node_modules
  find "${REPO_ROOT}" -path "*/node_modules/${package_name}" -type d | head -1
}

# Extract function names from a file
extract_functions() {
  local file=$1
  grep -oP 'export\s+(function|const)\s+\K\w+(?=\s*[=(])' "$file" 2>/dev/null || true
}

# Extract type names from a file
extract_types() {
  local file=$1
  grep -oP 'export\s+(type|interface|enum)\s+\K\w+' "$file" 2>/dev/null || true
}

# Search for matching signature in package
search_in_package() {
  local signature=$1
  local package_path=$2

  if [ ! -d "$package_path" ]; then
    return 1
  fi

  # Search in src directory
  local src_path="${package_path}/src"
  if [ -d "$src_path" ]; then
    grep -r "export.*${signature}" "$src_path" 2>/dev/null || true
  fi
}

# Main scan logic
main() {
  echo -e "${BLUE}üîç DRY CHECK: Scanning modified files...${NC}\n"

  # Get modified files (staged + unstaged)
  local modified_files=$(git diff --name-only --diff-filter=AM HEAD)
  local staged_files=$(git diff --cached --name-only --diff-filter=AM)
  local all_files=$(echo -e "${modified_files}\n${staged_files}" | sort -u | grep -E '\.(ts|tsx|js|jsx)$' || true)

  if [ -z "$all_files" ]; then
    echo -e "${GREEN}‚úÖ No modified code files to scan${NC}"
    exit 0
  fi

  local file_count=$(echo "$all_files" | wc -l)
  local violation_count=0
  local signature_count=0

  # Scan each file
  while IFS= read -r file; do
    if [ ! -f "$file" ]; then
      continue
    fi

    # Extract signatures
    local functions=$(extract_functions "$file")
    local types=$(extract_types "$file")

    # Search for each function
    for func in $functions; do
      ((signature_count++))

      for package in "${SHARED_PACKAGES[@]}"; do
        local package_path=$(find_package "$package")
        local matches=$(search_in_package "$func" "$package_path")

        if [ -n "$matches" ]; then
          echo -e "${RED}‚ùå VIOLATION: ${file} ${func}()${NC}"
          echo -e "   Duplicates: ${package}"
          echo -e "   FIX: import { ${func} } from '${package}'"
          echo ""
          ((violation_count++))
          break
        fi
      done
    done

    # Search for each type
    for type in $types; do
      ((signature_count++))

      for package in "${SHARED_PACKAGES[@]}"; do
        local package_path=$(find_package "$package")
        local matches=$(search_in_package "$type" "$package_path")

        if [ -n "$matches" ]; then
          echo -e "${RED}‚ùå VIOLATION: ${file} ${type}${NC}"
          echo -e "   Duplicates: ${package}"
          echo -e "   FIX: import type { ${type} } from '${package}'"
          echo ""
          ((violation_count++))
          break
        fi
      done
    done
  done <<< "$all_files"

  # Summary
  echo -e "${BLUE}üìä SUMMARY:${NC}"
  echo "   Files scanned: ${file_count}"
  echo "   Signatures checked: ${signature_count}"

  if [ $violation_count -eq 0 ]; then
    echo -e "${GREEN}   ‚úÖ No duplications found${NC}"
    exit 0
  else
    echo -e "${RED}   Violations: ${violation_count}${NC}"
    exit 1
  fi
}

main "$@"
